apply plugin: 'com.android.application'

android {
    compileSdkVersion 28
    defaultConfig {
        applicationId "com.zjx.happy.learning"
        minSdkVersion 21
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'com.android.support:appcompat-v7:28.0.0'
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
}

/**-----------------Project相关示例------------------*/
// 访问Project的属性
println project.group // 打印组名
println version // 打印版本号，默认 unspecified
println project.name // 打印项目名
println rootProject.name // 打印根项目的名字
logger.quiet('Test project logger property') // 使用logger
for(String taskName : rootProject.defaultTasks) { // 获取默认任务
    println "defaultTask: $taskName"
}
println rootProject.ext.hello // 打印额外参数


/**-----------------Task相关示例------------------*/
// 定义 Task
println '---------定义Task的示例---------'
// 使用字符串作为任务名
task('helloA') {
    doLast {
        println("helloA task('name')")
    }
}

// 使用tasks的create方法
tasks.create('helloB') {
    doFirst {
        println("helloB tasks.create('name')")
    }
}

// 使用DSL特殊语法
task helloC {
    doLast {
        println("helloC task name")
    }
}

// 可以加上括号
task(helloD) {
    doLast {
        println("helloD task(name)")
    }
}

// 使用Map增加配置项
task copy(type: Copy)

// 覆盖了原 copy 任务
task copy(overwrite: true) {
    doLast {
        println('I am the new one.')
    }
}

task ('copy2', type: Copy, overwrite: true) {
    println 'i am copy 2'
}

// 使用 gradlew tasks 命令查看 helloE 的配置
task helloE {
    description 'i am helloE'
    group BasePlugin.BUILD_GROUP
    doLast {
        println('this is helloE')
    }
}

// 同时创建四个任务：task0、task1、task2、task3
4.times { counter ->
    task "task$counter" {
        doLast {
            println "I'm task number $counter"
        }
    }
}

println '---------访问Task的示例---------'

// 以helloE任务为例
println '任务helloE的name: ' + helloE.name
println '任务helloE的description: ' + project.helloE.description

// 利用tasks
println tasks.named('helloD').get().name
println tasks.copy.doLast {
    println 'configure by tasks.copy.doLast'
}
println tasks['helloC'].name
println tasks.getByName('helloB').name

println tasks.getByPath('helloE').path // 找不到抛异常UnknownTaskException
println tasks.getByPath(':app:helloE').path
def ehelloE = tasks.findByPath("EhelloE") // 找不到返回Null；
println ehelloE == null

// Task的额外属性
task myTask {
    ext.myProperty = "myValue"
}

task printTaskProperties {
    doLast {
        println myTask.myProperty
    }
}

println '---------DefaultTask的示例---------'

import javax.inject.Inject

// 使用 DefaultTask
class CustomTask extends DefaultTask {
    final String message
    final int number

    def content // 配置参数

    // 添加构造参数
    @Inject
    CustomTask(String message, int number) {
        this.message = message
        this.number = number
    }

    // 添加要执行动作
    @TaskAction
    def greet() {
        println content
        println "message is $message , number is $number !"
    }

}

// 使用tasks创建
// 需要传递两个参数，不能为null
tasks.create('myCustomTask1', CustomTask, 'hahaha', 110)
myCustomTask1.content = 'i love you'
myCustomTask1.doFirst {
    println 'my custom task do first'
}
myCustomTask1.doLast {
    println 'my custom task do last'
}

// 使用task创建，构造参数使用constructorArgs传递，参数不能为null
task myCustomTask2(type: CustomTask, constructorArgs: ['xixi', 120])
myCustomTask2.content = 'i hate you'

println '---------Task的执行分析---------'

// Task的执行分析
task greetA {
    // 在配置阶段执行
    println 'i am greet A, in configure'
}

task greetB << { // << 等价于 doFirst
    println 'i am greet B, in doFirst'

    // 不能继续配置doLast
//    doLast {
//        println 'i am greet B, in doLast'
//    }
}
greetB.doLast {
    println 'i am greet B, in doLast'
}

task greetC { // 可以显示声明 doFirst doLast
    // 在配置阶段执行
    println 'i am greet C, in configure'

    // 在执行阶段执行
    doFirst {
        println 'i am greet C, in doFirst'
    }

    // 在执行阶段执行
    doLast {
        println 'i am greet C, in doLast'
    }
}

println '---------Task的依赖和顺序---------'
// 任务的依赖和顺序
def versionD = '0.0'
task greetD {
    doLast {
        println "i am greet D, versionD is $versionD"
    }
}
// task的DAG图是在配置阶段生成的
// 还有 beforeTask 和 afterTask
gradle.taskGraph.whenReady {taskGraph ->
    if (taskGraph.hasTask('greetC')) {
        versionD = '1.0'
    } else {
        versionD = '1.0-alpha'
    }
}

gradle.taskGraph.beforeTask { Task task ->
    println "executing $task ..."
}

gradle.taskGraph.afterTask { Task task, TaskState state ->
    if (state.failure) {
        println "FAILED"
    }
    else {
        println "$task done"
    }
}

println '---------dependsOn 示例---------'

task dependsA { // 定义一个基础Task
    doLast {
        println 'i am depends A task'
    }
}

// 当执行B时，会先执行它的依赖任务A
task dependsB {
    dependsOn dependsA // 通过方法设置
    doLast {
        println 'i am depends B task'
    }
}

// 通过Map参数依赖任务A
task dependsC(dependsOn: dependsA) {
    doLast {
        println 'i am depends C task'
    }
}

// 任务D懒依赖任务E
// 任务E后定义
task dependsD {
    dependsOn 'dependsE'
    doLast {
        println 'i am depends D task'
    }
}

task dependsE {
    doLast {
        println 'i am depends E task'
    }
}

task dependsF {
    doLast {
        println 'i am depends F task'
    }
}
// 通过dependsOn方法同时依赖两个任务E和A
dependsF.dependsOn dependsE, dependsA

println '---------finalizedBy 示例---------'

task taskX {
    doLast {
        println 'i am task X'
    }
}

task taskY {
    doLast {
        println 'i am task Y'
    }
}

task taskZ {
    doLast {
        println 'i am task Z'
    }
}
// 任务X执行后，立刻执行任务Y和任务Z
taskX.finalizedBy taskY, taskZ

task taskM {
    doLast {
        println 'i am task M'
    }
}

task taskN {
    finalizedBy taskM
    doLast {
        println 'i am task N'
    }
}

println '---------mustRunAfter 示例---------'

task taskA {
    doLast {
        println 'i am task A'
    }
}

task taskB {
    doLast {
        println 'i am task B'
    }
}
// 任务A必须在任务B之后执行
taskA.mustRunAfter taskB

println '---------shouldRunAfter 示例---------'

// shouldRunAfter 示例
task shouldTaskC << {
    println 'i am task C'
}

task shouldTaskD << {
    println 'i am task D'
}

shouldTaskC.shouldRunAfter shouldTaskD

// shouldRunAfter 失效的例子
task shouldTaskX {
    doLast {
        println 'taskX'
    }
}
task shouldTaskY {
    doLast {
        println 'taskY'
    }
}
task shouldTaskZ {
    doLast {
        println 'taskZ'
    }
}
shouldTaskX.dependsOn shouldTaskY
shouldTaskY.dependsOn shouldTaskZ
shouldTaskZ.shouldRunAfter shouldTaskX // 这里其实是失效的

println '---------shouldRunAfter 示例---------'

tasks.create('greetE') {
    doLast {
        println 'i am greetE'
    }
}
// 构建过程中添加任务时会触发此回调，常用来配置一些任务依赖或者赋值
// 经测试，该回调只针对插件中的任务有效
project.tasks.whenTaskAdded { task ->
    println "task ${task.name} add"
    if (task.name == 'HelloSecond') {
        task.dependsOn 'greetE'
    }
}

// 定义一个自定义插件
class SecondPlugin implements Plugin<Project> {

    @Override
    void apply(Project project) {
        println 'Hello Second Gradle Plugin'
        // 添加一个task到project中
        project.task('HelloSecond', {
            println '===== SecondPlugin HelloSecond Task ====='
            logger.quiet('hello')
        })
    }
}

apply plugin: SecondPlugin

println '---------跳过任务示例---------'
// 跳过任务示例
task disableMe {
    doLast {
        println 'This should not be printed if the task is disabled.'
    }
}
disableMe.enabled = false // 禁止该任务执行

task sayBye {
    doLast {
        println 'i am sayBye task'
    }
}
// 只有当project中没有 skipSayBye 属性时，任务才可以执行
sayBye.onlyIf { !project.hasProperty('skipSayBye') }

task byeTask {
    doLast {
        println 'We are doing the byeTask.'
    }
}
// 不会影响后续任务的执行
byeTask.doFirst {
    // Here you would put arbitrary conditions in real life.
    // But this is used in an integration test so we want defined behavior.
    if (true) { throw new StopExecutionException() }
}
task nextTask {
    dependsOn('byeTask') // 先执行byeTask，而byeTask会异常中断
    doLast { // 并不影响nextTask的执行
        println 'I am not affected'
    }
}

// 故意超时
//task hangingTask() {
//    doLast {
//        Thread.sleep(100000)
//    }
//    timeout = Duration.ofMillis(500)
//}

println '---------Task 的规则---------'
// 第一个参数是该规则的描述
// 第二个闭包参数是该规则要执行的动作
tasks.addRule("Pattern: ping<ID>") { String taskName ->
    if (taskName.startsWith("ping")) {
        task(taskName) {
            doLast {
                println "Pinging: " + (taskName - 'ping')
            }
        }
    }
}

task groupPing {
    dependsOn pingServer1, pingServer2
}